#!/usr/bin/env python3
"""
üåê AI Job Application Agent - Web API Server
===========================================
FastAPI backend that bridges the React frontend with Python agents
Integrates with Coral Protocol and AIML API
"""

import asyncio
import os
import json
import sqlite3
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
from contextlib import asynccontextmanager

import uvicorn
from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, StreamingResponse
from pydantic import BaseModel
import requests
from dotenv import load_dotenv

# Import our existing agent
import sys
import importlib.util
sys.path.append('.')

# Import the complete job agent (handling hyphenated filename)
try:
    spec = importlib.util.spec_from_file_location("complete_job_agent", "complete-job-agent.py")
    complete_job_agent_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(complete_job_agent_module)
    CompleteJobApplicationAgent = complete_job_agent_module.CompleteJobApplicationAgent
except ImportError as e:
    print(f"‚ùå Failed to import CompleteJobApplicationAgent: {e}")
    print("üìù Creating a simplified version for API...")
    
    # Fallback: Create a simplified agent class
    class CompleteJobApplicationAgent:
        def __init__(self, name):
            self.agent_name = name
        
        def parse_resume(self, resume_text=None):
            return {
                "name": "API User",
                "skills": ["Python", "React", "Node.js", "AWS"],
                "experience_level": "Senior",
                "years_experience": "5+"
            }
        
        def search_jobs(self, resume_data):
            return [{
                "id": "job_001",
                "title": "Senior Developer",
                "company": "Tech Company",
                "match_score": 85,
                "requirements": ["Python", "React", "AWS"]
            }]
        
        async def generate_cover_letter_llm(self, resume_data, job_data):
            return "Sample cover letter generated by API fallback."

# Load environment variables
load_dotenv()

# Pydantic models for API
class ResumeUpload(BaseModel):
    filename: str
    content: str

class JobApplicationRequest(BaseModel):
    resume_data: Dict[str, Any]
    preferences: Optional[Dict[str, Any]] = None

class AgentStatus(BaseModel):
    agent_id: str
    status: str
    current_step: str
    progress: int
    results: Optional[Dict[str, Any]] = None

# Global state management
active_agents: Dict[str, CompleteJobApplicationAgent] = {}
agent_status: Dict[str, AgentStatus] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("üöÄ Starting AI Job Application Agent API Server")
    print("üåê Frontend integration ready")
    yield
    # Shutdown
    print("üîÑ Shutting down API server")

# Initialize FastAPI app
app = FastAPI(
    title="AI Job Application Agent API",
    description="Backend API for AI-powered job application automation with Coral Protocol",
    version="1.0.0",
    lifespan=lifespan
)

# Add CORS middleware for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],  # React dev servers
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check endpoint
@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "coral_server": await check_coral_server(),
        "aiml_api": check_aiml_api_config()
    }

async def check_coral_server():
    """Check if Coral Protocol server is running"""
    try:
        response = requests.get("http://localhost:5555", timeout=2)
        return "connected" if response.status_code in [200, 404] else "disconnected"
    except:
        return "disconnected"

def check_aiml_api_config():
    """Check if AIML API is configured"""
    api_key = os.getenv("AIML_API_KEY")
    return "configured" if api_key and api_key != "your_aiml_api_key_here" else "not_configured"

# Resume upload endpoint
@app.post("/api/resume/upload")
async def upload_resume(file: UploadFile = File(...)):
    """Upload and parse resume"""
    try:
        # Read file content
        content = await file.read()
        
        # For now, simulate resume parsing (in production, use PDF parser)
        resume_data = {
            "id": str(uuid.uuid4()),
            "filename": file.filename,
            "upload_time": datetime.now().isoformat(),
            "parsed_data": {
                "name": "Uploaded Candidate",
                "email": "candidate@email.com",
                "skills": ["React", "TypeScript", "Python", "Node.js", "AWS", "Docker"],
                "experience_level": "Senior",
                "years_experience": "5+",
                "education": "Computer Science",
                "summary": "Experienced software developer seeking new opportunities"
            }
        }
        
        return {
            "success": True,
            "message": "Resume uploaded and parsed successfully",
            "resume_data": resume_data
        }
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Resume upload failed: {str(e)}")

# Start job application process
@app.post("/api/job-application/start")
async def start_job_application(request: JobApplicationRequest, background_tasks: BackgroundTasks):
    """Start the AI job application process"""
    try:
        # Create unique agent ID
        agent_id = str(uuid.uuid4())
        
        # Initialize agent
        agent = CompleteJobApplicationAgent(f"web-agent-{agent_id[:8]}")
        active_agents[agent_id] = agent
        
        # Initialize status
        agent_status[agent_id] = AgentStatus(
            agent_id=agent_id,
            status="initializing",
            current_step="Starting AI job application process",
            progress=0
        )
        
        # Run agent in background
        background_tasks.add_task(run_job_application_workflow, agent_id, request.resume_data)
        
        return {
            "success": True,
            "agent_id": agent_id,
            "message": "Job application process started",
            "status": agent_status[agent_id].dict()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start job application: {str(e)}")

async def run_job_application_workflow(agent_id: str, resume_data: Dict):
    """Run the complete job application workflow"""
    try:
        agent = active_agents[agent_id]
        
        # Update status: Resume parsing
        agent_status[agent_id].status = "parsing_resume"
        agent_status[agent_id].current_step = "Parsing resume and extracting skills"
        agent_status[agent_id].progress = 20
        
        # Step 1: Parse resume (using provided data)
        parsed_resume = resume_data.get("parsed_data", {})
        await asyncio.sleep(1)  # Simulate processing time
        
        # Update status: Job search
        agent_status[agent_id].status = "searching_jobs"
        agent_status[agent_id].current_step = "Searching for matching job opportunities"
        agent_status[agent_id].progress = 40
        
        # Step 2: Search jobs
        matching_jobs = agent.search_jobs(parsed_resume)
        await asyncio.sleep(2)  # Simulate search time
        
        # Update status: Generating cover letters
        agent_status[agent_id].status = "generating_cover_letters"
        agent_status[agent_id].current_step = "Creating personalized cover letters with AI"
        agent_status[agent_id].progress = 70
        
        # Step 3: Generate cover letters for top matches
        cover_letters = []
        for job in matching_jobs[:2]:  # Top 2 jobs
            cover_letter = await agent.generate_cover_letter_llm(parsed_resume, job)
            cover_letters.append({
                "job_id": job["id"],
                "job_title": job["title"],
                "company": job["company"],
                "cover_letter": cover_letter,
                "match_score": job["match_score"]
            })
            await asyncio.sleep(1)  # Simulate generation time
        
        # Update status: Complete
        agent_status[agent_id].status = "completed"
        agent_status[agent_id].current_step = "Job application process complete"
        agent_status[agent_id].progress = 100
        agent_status[agent_id].results = {
            "resume": parsed_resume,
            "jobs_found": len(matching_jobs),
            "matching_jobs": matching_jobs,
            "cover_letters": cover_letters,
            "completion_time": datetime.now().isoformat()
        }
        
    except Exception as e:
        # Update status: Error
        agent_status[agent_id].status = "error"
        agent_status[agent_id].current_step = f"Error: {str(e)}"
        agent_status[agent_id].progress = 0
        print(f"Workflow error for agent {agent_id}: {e}")

# Get agent status
@app.get("/api/job-application/{agent_id}/status")
async def get_agent_status(agent_id: str):
    """Get the current status of a job application process"""
    if agent_id not in agent_status:
        raise HTTPException(status_code=404, detail="Agent not found")
    
    return {
        "success": True,
        "status": agent_status[agent_id].dict()
    }

# Get agent results
@app.get("/api/job-application/{agent_id}/results")
async def get_agent_results(agent_id: str):
    """Get the complete results of a job application process"""
    if agent_id not in agent_status:
        raise HTTPException(status_code=404, detail="Agent not found")
    
    status = agent_status[agent_id]
    if status.status != "completed":
        raise HTTPException(status_code=400, detail="Job application process not completed yet")
    
    return {
        "success": True,
        "agent_id": agent_id,
        "results": status.results
    }

# Get audit logs
@app.get("/api/audit/logs")
async def get_audit_logs(limit: int = 50):
    """Get audit logs from the database"""
    try:
        db_path = "audit_log.db"
        if not os.path.exists(db_path):
            return {"success": True, "logs": []}
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT timestamp, agent_name, action, status, details 
            FROM audit_logs 
            ORDER BY timestamp DESC 
            LIMIT ?
        """, (limit,))
        
        logs = []
        for row in cursor.fetchall():
            logs.append({
                "timestamp": row[0],
                "agent_name": row[1],
                "action": row[2],
                "status": row[3],
                "details": row[4]
            })
        
        conn.close()
        
        return {
            "success": True,
            "logs": logs,
            "count": len(logs)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve audit logs: {str(e)}")

# Server-sent events for real-time updates
@app.get("/api/job-application/{agent_id}/stream")
async def stream_agent_status(agent_id: str):
    """Stream real-time status updates for a job application process"""
    if agent_id not in agent_status:
        raise HTTPException(status_code=404, detail="Agent not found")
    
    async def generate():
        last_status = None
        while True:
            current_status = agent_status.get(agent_id)
            if current_status and current_status != last_status:
                yield f"data: {json.dumps(current_status.dict())}\n\n"
                last_status = current_status
                
                # Stop streaming if completed or error
                if current_status.status in ["completed", "error"]:
                    break
            
            await asyncio.sleep(1)  # Check every second
    
    return StreamingResponse(
        generate(),
        media_type="text/plain",
        headers={"Cache-Control": "no-cache", "Connection": "keep-alive"}
    )

# List active agents
@app.get("/api/agents")
async def list_active_agents():
    """List all active agents"""
    agents = []
    for agent_id, status in agent_status.items():
        agents.append({
            "agent_id": agent_id,
            "status": status.status,
            "current_step": status.current_step,
            "progress": status.progress
        })
    
    return {
        "success": True,
        "agents": agents,
        "count": len(agents)
    }

if __name__ == "__main__":
    print("üöÄ Starting AI Job Application Agent API Server")
    print("üåê React Frontend Integration Ready")
    print("üì° Coral Protocol Integration Active")
    print("ü§ñ AIML API Integration Enabled")
    print()
    print("API Endpoints:")
    print("  - POST /api/resume/upload - Upload resume")
    print("  - POST /api/job-application/start - Start job search")
    print("  - GET  /api/job-application/{id}/status - Get status")
    print("  - GET  /api/job-application/{id}/results - Get results")
    print("  - GET  /api/audit/logs - View audit logs")
    print("  - GET  /api/agents - List active agents")
    print()
    
    uvicorn.run(
        "web_api:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )